<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>水题 on Aynxul03 写字的地方</title>
    <link>https://ayx.moefox.tech/tags/%E6%B0%B4%E9%A2%98/</link>
    <description>Recent content in 水题 on Aynxul03 写字的地方</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 19 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://ayx.moefox.tech/tags/%E6%B0%B4%E9%A2%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>题解 P1650 田忌赛马</title>
      <link>https://ayx.moefox.tech/p1650/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ayx.moefox.tech/p1650/</guid>
      <description>(题面来自洛谷)
题目描述 我国历史上有个著名的故事： 那是在2300年以前。齐国的大将军田忌喜欢赛马。他经常和齐王赛马。他和齐王都有三匹马：常规马，上级马，超级马。一共赛三局，每局的胜者可以从负者这里取得200银币。每匹马只能用一次。齐王的马好，同等级的马，齐王的总是比田忌的要好一点。于是每次和齐王赛马，田忌总会输600银币。
田忌很沮丧，直到他遇到了著名的军师――孙膑。田忌采用了孙膑的计策之后，三场比赛下来，轻松而优雅地赢了齐王200银币。这实在是个很简单的计策。由于齐王总是先出最好的马，再出次好的，所以田忌用常规马对齐王的超级马，用自己的超级马对齐王的上级马，用自己的上级马对齐王的常规马，以两胜一负的战绩赢得200银币。实在很简单。
如果不止三匹马怎么办？这个问题很显然可以转化成一个二分图最佳匹配的问题。把田忌的马放左边，把齐王的马放右边。田忌的马A和齐王的B之间，如果田忌的马胜，则连一条权为200的边；如果平局，则连一条权为0的边；如果输，则连一条权为－200的边……如果你不会求最佳匹配，用最小费用最大流也可以啊。 然而，赛马问题是一种特殊的二分图最佳匹配的问题，上面的算法过于先进了，简直是杀鸡用牛刀。现在，就请你设计一个简单的算法解决这个问题。
输入格式 第一行一个整数n，表示他们各有几匹马（两人拥有的马的数目相同）。第二行n个整数，每个整数都代表田忌的某匹马的速度值(0 &amp;lt;= 速度值&amp;lt;= 100)。第三行n个整数，描述齐王的马的速度值。两马相遇，根据速度值的大小就可以知道哪匹马会胜出。如果速度值相同，则和局，谁也不拿钱。
【数据规模】
对于20%的数据，1&amp;lt;=N&amp;lt;=65；
对于40%的数据，1&amp;lt;=N&amp;lt;=250；
对于100%的数据，1&amp;lt;=N&amp;lt;=2000。
输出格式 仅一行，一个整数，表示田忌最大能得到多少银币。
输入输出样例 输入 #1
3 92 83 71 95 87 74 输出 #1
200 分析 都在代码注释里了
代码 // Problem: P1650 田忌赛马 // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P1650 // Memory Limit: 125 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org)  #include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n, a[2001],	//田忌的马 	b[2001],	//齐王的马 	m1, m2, qian; int main(){ scanf(&amp;#34;%d&amp;#34;,&amp;amp;n); for(int i=0;i&amp;lt;n;i++) scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i]); for(int i=0;i&amp;lt;n;i++) scanf(&amp;#34;%d&amp;#34;,&amp;amp;b[i]); sort(a,a+n); sort(b,b+n); int n1=n-1, n2=n-1; while(m1&amp;lt;=n1){ if(a[n1]&amp;gt;b[n2]){	//田忌最快的比齐王最快的快 	qian+=200;	//赢钱 	n1--,n2--;	//两边各去掉一匹马 	}else if(a[n1]&amp;lt;b[n2]){//田忌最快的赢不了齐王最快的，就丢一匹最慢的 	qian-=200;	//输钱 	m1++,n2--; }else{	//如果 势 均 力 敌 的话 	if(a[m1]&amp;gt;b[m2]){ //田忌最慢的能赢齐王最慢的，就上 	qian+=200;	//赢钱 	m1++,m2++;	}else{	//赢不了就用最慢的消耗齐王最快的 	if(a[m1]&amp;lt;b[n2]) qian-=200;	//我 再 忍 你 一 手 	m1++,n2--; } } } printf(&amp;#34;%d&amp;#34;,qian); return 0; } 修改记录</description>
    </item>
    
  </channel>
</rss>
